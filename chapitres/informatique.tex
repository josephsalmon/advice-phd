
Pour les nouveaux en programmation, il existe de nombreux langages informatiques, qui sont très 
différents les uns des autres. Nous en listerons ici un certain nombre avec des exemples d'utilisation 
optimum. Il existe en gros quatre grandes familles de code :
 %jamais été très convaincu par les familles de code on retrouve du fonctionnel et de l'objet
%dans presque totues les familles par exemple (Yann)

\begin{enumerate}
\item procédural (C, Fortran, Pascal, Basic, \ldots)
\item orienté objet (Java, C\#, Python, \ldots)
\item fonctionnel (OCaml, Lisp, \ldots)
\item logique (Prolog)
\end{enumerate}

Un site pr\'esentant des livres gratuits sur un la plupart des langages existants est
\url{https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md}

Les plus utilisées sont les deux premières, en sachant qu'il existe des hybrides, notamment le C++ 
qui appartient dans sa structure même aux deux premières familles. 

\section{Programmation procédurale}

Les langages procéduraux sont une suite de routines qui s'exécutent dans l'ordre. Ce sont des ordres 
donnés à la machine qui s'exécutent pas à pas (comme une recette de cuisine).\\

Nous ne parlerons dans ce document que du C. 

\subsection{C}

C'est un langage qui n'est pas simple à prendre en main et il est \`a déconseiller sauf pour 
une chose : sa rapidité ! Pour un chercheur qui n'est pas versé dans l'art de la programmation,
il vaut mieux apprendre un langage plus moderne.

\subsubsection*{Avantages du C}
 Pour une question subtile sur le langage C, la réponse est certainement dans cette 
 \href{http://c-faq.com/}{FAQ}.
 
 
 
\begin{itemize}
\item une fois compilé, le C est très rapide, et est très proche des instructions machines,
donc si  vous devez faire du temps réel \textbf{FAITES} du C
\item le C est facilement parallélisable puisque vous contrôlez la mémoire
par exemple en utilisant \href{http://openmp.org/}{OPENMP} (possible aussi en C++)
\item le C et est un langage répandu et beaucoup de gens le comprennent
\end{itemize}

\subsubsection*{Défauts du C}

\begin{itemize}
\item il faut s'occuper de la gestion mémoire soi-même
\item coder en C est souvent plus long que dans un langage moderne
\item il n'y a pas de libraire par défaut pour les structures de données courantes ou les fonctions souvent utiles
%\item faut compiler à chaque fois
%\item c'est pas portable (ce qui marche chez vous ne marche pas chez votre voisin)
%\item c'est vieux
%\item c'est prétentieux de coder en C
\end{itemize}

\section{Programmation orientée objet}

La programmation orientée objet est difficile à définir et vous trouverez sur le net de nombreuses 
définitions possibles. En bref, c'est la même chose que précédemment mais en mieux. C'est une recette de cuisine qui se 
découpe en de nombreuses sous-recette de cuisine ultra spécialisées (comment cuire la viande,
assaisonner les légumes, faire les sauces, etc.).\\

% Conseil : n'écoutez JAMAIS les vieux briscards du code qui vous parle de VRAI programmation objet 
% ou de full OOP (oriented object programming), c'est des chieurs qu'il faut ignorer. 
% Mais il faut savoir que l'orienté objet c'est le bien le reste c'est le mal. 

Nous parlerons de deux langages uniquement : C++ et Python. 
% Me demandez pas pourquoi c'est juste que j'aime pas JAVA et que j'aime bien ces deux là! 

\subsection{C++}

Le C++ a été inventé pour faire du C orienté objet. En réalité c'est un hybride et introduit une
nouveauté : les types templétés extrêmement utiles quand on sait les utiliser.


\subsubsection*{Avantages du C++}

\begin{itemize}
\item c'est presque aussi rapide que du C mais moins quand même
\item les types templétés sont tr\`es pratiques \mytodo{pour???}
%\item les vrais, ils font du C++
\item on peut faire facilement du calcul parallèle % mais en C aussi
\end{itemize}

\subsubsection*{Défaut du C++}

\begin{itemize}
\item c'est compliqué à mettre en oeuvre
%\item faut compiler
%\item c'est presque aussi long pour coder
\item ce n'est pas portable %qu'est ce que tu entends par c'est pas portable ? 
\end{itemize}

\subsection{Python}

Python est un langage moderne, agréable d'utilisation et concis.
Il est parfaitement adapté à l'écriture de programmes dont les performances ne sont
pas importantes. Python tend à devenir un standard: ce langage est enseigné au lycée 
et en classes préparatoires (ainsi que dans les universités et les grandes \'ecoles). 

Il est donc utile de le connaître si vous avez à enseigner.

Pour apprendre Python, vous pouvez utiliser le site 
\href{http://www.codecademy.com/tracks/python}{codecademy} 
qui donne des exercices en ligne pour apprendre par l'exemple.
Le livre de Kevin Sheppard peut aussi s'avérer un compl\'ement utile: 
\href{http://www.kevinsheppard.com/images/0/09/Python_introduction.pdf}{Python Introduction}.

Enfin pour respecter un tant soit peu la syntaxe de ce langage il est bon de suivre les préceptes
de \url{http://www.python.org/dev/peps/pep-0008/} et tester la validité  de la syntaxe avec
\url{https://pypi.python.org/pypi/pep8}.

\subsubsection*{Avantages de Python}
\begin{itemize}
\item c'est simple
\item c'est réutilisable tel quel ! 
\item c'est interprété
%\item les gentils font du Python
\item c'est court à coder et à  tester
\item les tests en Python sont faciles %???
\item c'est portable
\item pip (Python Package Index):  pratique pour installer des nouveaux packages!
\item on peut faire comme du Matlab mais en gratuit ! %à expliquer plus loin
\end{itemize}

\subsubsection*{Défauts de Python}
\begin{itemize}
\item il n'y a pas les templates
\item n'importe qui peut faire n'importe quoi ! %ça n'est pas typé
\item c'est lent
\end{itemize}

\section{Dérivés et autres langages liés à des programmes}

Il existe des logiciels qui ont tellement apportés dans un domaine de recherche qu'ils sont 
indispensables dans votre travail. Notamment, si vous faites des statistiques, vous ne pourrez
 faire l'impasse d'une bonne formation en \lstinline+R+. De m\^eme en traitement du signal, 
Matlab a réussit à s'imposer comme un standard.\\

Ce sont de bons logiciels qu'il est intéressant d'utiliser, notamment dans le cas de Matlab, 
vous aurez la possibilité d'utiliser tout la base \href{http://www.mathworks.fr/matlabcentral/fileexchange}{Mathworks}.
Toutefois, il est intéressant de noter que la syntaxe de Python se reprochant de celle de Matlab, il a 
été développé en Python des bibliothèques et outils permettant de programmer en Python comme en Matlab: 
\href{http://www.numpy.org/}{numpy}, \href{http://www.scipy.org/}{scipy} et \href{http://matplotlib.org/}{matplotlib}.\\



\section{Trucs et astuces pour choisir le langage adéquate}

En fonctions de différentes problématiques il est de bon ton de savoir ce que vous devriez utiliser :

\begin{itemize}
\item Temps réel : C et c'est TOUT !!!!
\item Traitement d'image ou du son: C++ pour de grosses données, sinon Python ou Matlab
\item Vision 3D : C++ avec opencv (bien qu'imparfaite cette librairie tend à devenir classique) 
et Python si vous avez de toutes petites données
\item Computer graphics : C++ 
\item Statistiques  et machine learning : R, Python et Matlab
\end{itemize}  

\section{Bonnes pratiques en programmation scientifiques}

\subsection{Bonnes pratiques générales: DOCUMENTATION}

La première est unique règle qui compte c'est : DOCUMENTEZ!
Le reste ne peut être que des conseils superflus, DOCUMENTEZ! 

Une application, un programme, un code n'est jamais totalement perdu si 
il est accompagné d'une documentation, donc DOCUMENTEZ !\\

Il ne sert à rien de dire qu'une documentation doit contenir telle ou telle section, il faut juste 
qu'elle permette de comprendre le but du code, comment on le lance et de quoi il a besoin, DOCUMENTEZ! \\

Plus votre code sera documenté et notamment en documentation externe (README, User case, etc,.) aussi 
bien que documentation interne (commentaire du code), et plus vos papiers seront cités. 
Et plus vos papiers seront cités et plus vous pourrez obtenir un poste, DOCUMENTEZ! \\

La documentation ne sert pas seulement à la communauté, elle est avant tout là pour vous aider. 
\`A la question :"\`A quoi sert cette fonction?" une documentation permet de rappeler qu'elle
 est là pour minimiser un bidule selon un algo quelconque ! 

De plus, vous devrez forcément un jour donner votre code \`a quelqu'un (ce quelqu'un
pouvant \^etre vous m\^eme dans XXX mois, années,etc.):
la documentation permet alors \`a la personne perdue de comprendre le plus rapidement possible 
votre démarche, et à quoi servent les différentes pièces du puzzle ainsi que comment elles 
s'imbriquent. DOCUMENTEZ!

\subsubsection*{fichier README }

Tout le monde ne sera pas d'accord sur ce que doit contenir un bon README, malgré tout tentons une
 liste assez général et parfaitement subjective sur ce qu'il est bon d'y trouver : 
\begin{itemize}
\item une description détaillée du code. Permet à tout le monde de savoir quel est votre but ultime
\item une description très détaillée des entrées, sorties et paramètres. N'ayez pas peur de dire que
 vous ne traitez QUE tel cas ou que tel jeux de paramètres ou tel type d'entrée. Dans le cas où vous 
partageriez votre code et qu'il soit un tant soit peu intéressant, il se peu que la communauté s'empare 
de votre oeuvre et vous aide à l'améliorer. Mais personne ne le fera jamais pour un code non documenté 
(ou trop succinctement).
\item un lien avec votre article. TOUS vos codes doivent être en relation avec des publications qui 
devront être citées en cas d'utilisation. 
\item un manuel d'installation (le coup de compilation : ./make ...) contenant les 
dépendances AVEC leurs version (pas d'opencv tout seul par pitié : v1.16 permettra à quelqu'un de 
voir d'un seul coup d'oeil s'il va passer trois heure ou 2 minutes à compiler votre code). 
\mytodo{benoit: tu peux rendre ca lisible}
\item des exemples d'utilisation (./toto -r 65 plop.dat) et potentiellement un cas pratique, sachant
qu'un cours exemple vaut mieux qu'un long discours. Pour que
 cette partie soit intéressante et si le code est en correspondance avec une publication, mettez 
un ou deux exemples d\'ej`a développés dans votre papier.
\item Si possible un schéma de votre code (comme un arbre généalogique qui partirais de la fonction
 principale appelée par l'exécution du code vers les codes plus spécialisés)
\end{itemize}

\subsubsection*{Commentaires}

Remarquez tout d'abord qu'un simple petit commentaire en début de fonction n'est pas 
ce qu'on appelle commenter son code. 
Il faut en effet un commentaire:

\begin{itemize}
 \item pour chaque fonction,
d\'ecrivant  son but, ses entrées, ses sorties et sur sa place dans l'algorithme globale.

 \item pour chaque boucle et pour chaque calcul important. 
\end{itemize}
Exemple :
\begin{lstlisting}[style=pythonsty]
int test_tmp_of_doom(int *var, double **plop) 

/* fonction qui prend en entree un tableau de reference de 
pixel et une image de masque de covariance
 et qui renvoie l'indice du pixel contenant la plus haute 
valeur de truc */

/* Cette fonction est utile dans le calcul des extrema 
interdependant des chaines de kikoolol */

int plop=42,temp=-1;
int i=0;

for(i=0;i<plop;i++){
/* parcours des index! */
if (var[i] < plop[var[i]][i]) /*cherche + haute valeur de truc*/
/* il n'y a pas de segmentation fault car les indices sont compris 
entre 0 et 40 ... bref tout commentaire permettant de comprendre 
ce geste singulier et fort peu ordinaire */

temp = i;
}

\end{lstlisting}
Bref si vous regardez ce code, les variables sont mal nommées et rien n'a de sens MAIS les
 commentaires explique tout, sans ça, c'est le flou le plus total.

Un bon conseil est parfois de se servir des commentaires comme colonne vertébrale de votre 
code. Vous commencez d'abord par écrire les commentaires décrivant en détail votre algorithme 
PUIS vous remplissez les trous! Avec ça plus jamais aucun de problème!

\subsubsection*{Nomenclature}

Beaucoup de personnes vous donnerons de bons conseils et ne les suivront pas et soyons honnêtes, 
tout le monde a des variables qui s'appelle toto ou tmp, et c'est pas grave, si il s'agit de 
variable TRÈS locales pas de problème. 
Voici juste quelques petits conseils pour mieux choisir 
les noms:

\begin{itemize}
\item Garder la même nomenclature dans TOUT votre code (un tableau d'index qui s'appelle "index[]" 
ne doit pas s'appeler autrement ailleurs "Index[]" "var[]", et c'est la confusion assurée)
\item Choisissez comme nom de variables celles que vous utiliserez dans votre article 
(si un truc est appelé béta dans un article sur lequel vous vous fondez appelez votre put*** 
de variable "beta" et c'est tout!)
\item Éviter de mettre un coup des majuscules pour les fonctions puis en minuscules, etc.
Mettez tout en minuscule si vous n'êtes pas assez rigoureux pour garder le même typage tout 
au long de vos codes (majuscules pour fonctions, minuscules pour les variables).
\end{itemize}

\subsection{Bonnes pratiques générales dans le code}

\begin{itemize}
\item Testez chaque entrée fourni par l'utilisateur, n'oubliez jamais qu'il 
n'est là pour expérimenter les bugs laissés négligemment par 
vous! De plus cet utilisateur c'est peut-être vous dans 
le futur ! Donc il est bon de tester et de renvoyer des erreurs 
compréhensibles par tout le monde concernant les erreurs. Par exemple: 
"on a dit une image png en entrée et pas autre chose!"
\item faites un --help ou un usage dans le cas où les personnes ne rentre QUE le nom du programme : m\^eme
si cela n'arrive que quand la personne n'a pas lu le README amoureusement écrit par vos soin! Un bon
 --help peut être un beau RTFM!
\item INDENTEZ votre code
\item jamais de fonction trop longues (si ça dépasse 50 lignes de code, c'est que c'est trop
 long et que vous devriez externaliser des fonctions)
\end{itemize}

\subsubsection*{Debugger un code}

Débugger va vous prendre beaucoup de temps, incluez le dans vos prévisions, si un code doit marcher 
dans deux semaines, comptez trois semaines avec une bonne semaine de debuggage et de tests. Votre ami pour
le débuggage est simplement la fonction d'écriture sur la sortie standard (printf !). Cela vous 
permet de savoir d'où  viens le bug et souvent de mettre en avant les différents états des variables.


\subsubsection*{C/C++}

Pour éviter les problèmes allouez toujours la mémoires là où vous la libérer. Sinon, cela
fini invariablement par créer des fuites mémoires de partout. Si vous faites 
un malloc dans une fonction c'est que vous faites un free dans la MÊME fonction. \\

En C++, lorsque vous devez passer des images, matrices, structures, tableaux, string  etc ... Qui 
peuvent contenir beaucoup de données FAITES TOUJOURS un passage par référence et pas par copie :\\

int plop (std::string toto) //(copie dans la mémoire toto donc si le string fait 2Go, bah à chaque
 appel de la fonction vous recopier 2Go => pas ultime!)\\

int plop (const std::string\& toto) //utilise un pointeur sur la mémoire contenant les 2Go sans
 jamais les copier ! Le const permet d'éviter de pouvoir modifier la chaîne de caractère !\\

\subsubsection*{Python}

Lorsque vous utilisez des fonction de bibliothèques externes, éviter : \\

\begin{lstlisting}[style=pythonsty]
from lib_externe..sous_fnctn import read_image
...
read_image(input)
\end{lstlisting}
Car lorsque vous appellerez cette fonction on ne saura pas d'où elle vient, ainsi et même si 
c'est embêtant : \\

\begin{lstlisting}[style=pythonsty]
import lib_externe
...
lib_externe.fnctn.sous_fnctn.read_image(input) #c'est plus clair !
\end{lstlisting}
Le Python est un langage moins rigoureux que le C/C++ donc il vous faut l'être d'autant plus
 sinon le débuggage peut être un enfer 




\section{Langage de programmation et outils de calcul matriciel}

\mytodo{Jo, Alex: Python, Numpy, Scipy}

\mytodo{Jo, Charles, Benoit}

\subsubsection*{Matlab}

Prescrivez le FOR, il devrait être interdit en Matlab. Ce type de boucle est très lent, bref en Matlab 
faites des calcul matricielle ! Vous ne devriez d'ailleurs n'utiliser Matlab QUE pour ça !

Si vous ne connaissez rien d'autre, ce n'est pas grave mais au moins approfondissez vos connaissances 
en Matlab.  Sachez de plus qu'il existe Scipy, Matplotlib  qui sont des bibliothèques de fonctions Python 
qui permette de programmer comme en Matlab mais sans Matlab ! (Et le for est bien plus rapide 
en Python que sous Matlab)\\

Il existe une interface entre C/C++ et Matlab. C'est à dire que vous pouvez écrire des petits bout de code en C
pour les parties importantes de votre code et les intégrer grâce à des fichiers .mex dans un code matlab.

\mytodo{Jo: R, Adoop}

\subsubsection*{R} Ce langage est pour les statistiques uniquement. 
Il est pleins d'erreurs et d'inconsistances, mais
toute la communauté s'en sert (académique, banque, \textit{hedges fund}, etc.) alors parfois 
il faut y passer. 
Pour démarrer on peut conseiller \href{http://www.rstudio.com/}{Rstudio} qui a une bonne interface graphique.

\section{Calcul formel}
\mytodo{Yann: Sage,Maple, mathematica}


\subsubsection*{Sage}
Développé depuis quelques années comme une tentative de remplacement de tous les
autres logiciels de math formel,  \href{http://www.sagemath.org/}{SAGE} est un logiciel très intéressant.
C'est principalement un ensemble de programmes python qui interface tous les logiciels
libres de calcul symbolique (combinatoires, graphes, polynômes, corps \dots)
Vos programmes Sage sont en fait du Python et l'utilisation est très proche des 
autres librairie de python scientifique.
Notez que c'est un logiciel libre, activement développé notamment par des chercheurs français.

%todo parler des feuilles de calcul en ligne


